<!DOCTYPE html>
<meta charset="utf-8">
<title>Homework 2 Graph</title>
<style>
  .link {
    stroke: gray;
    stroke-width: 1.5px;
  }

  .node {
    /*fill: #66CC66;*/
    stroke: #000;
    stroke-width: 1px;
  }

  .node:hover {
    fill: red;
  }
  
  path.link {
  fill: none;
  stroke: #666;
  stroke-width: 1.5px;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
  <form>
  Scale:
    <label><input type="radio" name="scale" value="linear" checked>Linear</label>
    <label><input type="radio" name="scale" value="time">Time</label>
  </form>

<script>

var width = 900,
    height = 700;

var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height);

var fill = d3.scale.category10();

var graph = {nodes:[], links:[]};

var nb_nodes = 100, nb_cat = 10;
var names = ["gh-pages", "master"]
var dataset = d3.json("https://api.github.com/repos/Snugug/north/commits"+"?sha="+names[0], function(error, data){


graph.nodes = data.map(function(d, i) {  
  return { sha: data[i].sha, commit: data[i].commit, branch: names[0], date: data[i].commit.author.date } 
}); 

//var k = data.map(function(d, i) { return data[i].commit});
//console.log(k+" is ");

//var p = data.map(function(d, i) { return data[i].parents});
//console.log(Date.parse(graph.nodes[1].commit.author.date));
//sort here?

graph.nodes.map(function(d, i){
	d.date=Date.parse(graph.nodes[i].date);
	//console.log(d.date);
	graph.nodes.sort(function(a, b){
		return d3.ascending(a.date, b.date);
	});
});
//console.log(graph);

graph.nodes.map(function(d, i) {
//goes through the data array
 data[i].parents.map(function(e, j) {
    //for each data item, selects the parents, individually
    //then need to push parents to own link item, and
    //save the sha as the source
    graph.nodes.map(function(l, m) {
    //console.log( l)
    	if(l.sha == data[i].parents[j].sha){
      graph.links.push({"source": i	, "target": m })
		 //console.log(d.parents);
		//console.log(parents);
		//console.log("e is" + j);
		 //console.log(graph.links);
		}
		}) 
  });
  });
  console.log(graph);
  
  var dataset = d3.json("https://api.github.com/repos/Snugug/north/commits"+"?sha="+names[1], function(error, data){
  //console.log(graph.links);
 // graph.nodes = data.map(function(d, i) {  
 // return { sha: data[i].sha, commit: data[i].commit } 
//}); 

var t = data.map(function(d, i) {  
  return graph.nodes.push({ sha: data[i].sha, commit: data[i].commit,  branch: names[1],
  			 date: Date.parse(data[i].commit.author.date) }); 
}); 

graph.nodes.map(function(d, i){
	//d.date=Date.parse(graph.nodes[i].date);
	//console.log(d.date);
	graph.nodes.sort(function(a, b){
		return d3.ascending(a.date, b.date);
	});
});
//var k = data.map(function(d, i) { return data[i].commit});
//console.log(k+" is ");

//var p = data.map(function(d, i) { return data[i].parents});
//console.log(p);

t.map(function(d, i) {
//goes through the data array
 data[i].parents.map(function(e, j) {
    //for each data item, selects the parents, individually
    //then need to push parents to own link item, and
    //save the sha as the source
    graph.nodes.map(function(l, m) {
    //console.log( l)
    	if(l.sha == data[i].parents[j].sha){
      graph.links.push({"source": i	, "target": m })
		 //console.log(d.parents);
		//console.log(parents);
		//console.log("e is" + j);
		 //console.log(graph.links);
		}
		}) 
  })
  });

console.log(graph);

//console.log(graph.nodes[0].branch);

//d3.selectAll("circle").style("fill", function(d) {  
//		console.log("di is "+d); 
//	return fill("blue"); });


// Generate the force layout
var force = d3.layout.force()
    .size([width, height])
    .charge(-50)
    .linkDistance(10)
    .on("tick", tick)
    .on("start", function(d) {})
    .on("end", function(d) {})

function tick(d) {

  graph_update(0);
}


function force_layout() {

 force.nodes(graph.nodes)
      .links(graph.links)
      .start();
}

var xScale = d3.scale.ordinal()
                .domain(d3.range(graph.nodes.length))
                .rangeRoundBands([0, width], 1);
                console.log(graph.nodes.length);

var min = d3.min(graph.nodes, function(d){
	return d.date;
});

console.log(min);

var max = d3.max(graph.nodes, function(d){
	return d.date;
});

var tScale = d3.time.scale()
			.domain([min, max])
			.range([20, width-20]);
			
function time(){
	graph.nodes.forEach(function(d, i) {
    	 d.x = tScale(d.date);
  });
  graph_update(500);

};


function line_layout() {

  force.stop();

  graph.nodes.forEach(function(d, i) {
    //console.log(graph.nodes[i].branch);
    d.x = xScale(i);
    //d.x = tScale(d.date);
    if(graph.nodes[i].branch=="master"){
    	d.y = height/2;
    	//d.x = xScale(i);
    }else{
    	d.y = (height/2)+30;
    	 //d.x = xScale(i);
    }
    //d.x = xScale(i);
  });
  //node
   //.attr("x", function(d, i) {
     // return xScale(d.x);         // <-- Set x values
   //})

  graph_update(500);
}


function category_color() {
  d3.selectAll("circle").transition().duration(500).style("fill", function(d) { return fill(d.cat); });
}

function category_size() {
  d3.selectAll("circle").transition().duration(500).attr("r", function(d) { return Math.sqrt((d.cat+1)*10); });
}

function graph_update(delay) {

  link.transition().duration(delay)
      .attr("x1", function(d) { return d.target.x; })
      .attr("y1", function(d) { return d.target.y; })
      .attr("x2", function(d) { return d.source.x; })
      .attr("y2", function(d) { return d.source.y; });

  node.transition().duration(delay)
      .attr("transform", function(d) { 
        return "translate("+d.x+","+d.y+")"; 
      });
}

d3.select("input[value=\"linear\"]").on("click", line_layout );
d3.select("input[value=\"time\"]").on("click", time);


// build the arrow.
/*svg.append("svg:defs").selectAll("marker")
    .data(["end"])      // Different link/path types can be defined here
  .enter().append("svg:marker")    // This section adds in the arrows
    .attr("id", String)
    .attr("viewBox", "0 -5 10 10")
    .attr("refX", 15)
    .attr("refY", -1.5)
    .attr("markerWidth", 6)
    .attr("markerHeight", 6)
    .attr("orient", "auto")
  .append("svg:path")
    .attr("d", "M0,-5L10,0L0,5");*/
    

             
//var lineData = [{x:d.source.x, y:d.source.y}, {x:d.source.x, y:d.source.y+offset_y},
 //				{x:d.target.x, y:d.target.y+offset_y}, {x:d.target.x, y:d.target}];
 				
/*var line = d3.svg.line()
            .x(function(d) { return d.source.x; })
            .y(function(d) { return d.source.y; })
			.x(function(d) { return d.target.x; })
            .y(function(d) { return d.target.y; })
           ;*/
    
function line(d){ 
	d3.svg.line()
            .x(function(d) { return d.x; })
            .y(function(d) { return d.y; })
             .interpolate("linear");

}
        
var link = svg.selectAll(".link")
              .data(graph.links)
            .enter().append("path")
            .attr("d", function(d){
            var lineData = [{x:d.source.x, y:d.source.y}, {x:d.source.x, y:d.source.y+5},
 			{x:d.target.x, y:d.target.y+5}, {x:d.target.x, y:d.target}];
            		return line(lineData, d);
            		})
            .attr("class", "link")
              //.attr("marker-end", "url(#end)");

var node = svg.selectAll(".node")
              .data(graph.nodes)
            .enter()
              .append("g").attr("class", "node");

node.append("circle")
    .attr("r", 5)
    .attr("fill", function(d) {
		if(d.branch=="master"){
			return "blue";
		}else{
			return "#66CC66";
		}
   })
   .on("mouseover", function(d) {
   		d3.select(this).attr("fill", "red");
   })
   .on("mouseout", function(d){
   		d3.select(this).attr("fill", function(d) {
			if(d.branch=="master"){
				return "blue";
			}else{
				return "#66CC66";
			}
		});
   })
    .append("title")
   .text(function(d, i) {
        return d.branch;
   });

force_layout();
line_layout();
  });
});
</script>
</body>
</html>